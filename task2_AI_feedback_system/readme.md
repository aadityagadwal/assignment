Task 2 – Two-Dashboard AI Feedback System

Evaluation & Explanation

1. Overview

This task implements a production-style web-based AI feedback system with two dashboards:

User Dashboard (Public-facing) – Allows users to submit a rating and written feedback and receive an AI-generated response.

Admin Dashboard (Internal-facing) – Displays all submitted feedback along with AI-generated summaries and recommended actions.

The system is implemented as a single FastAPI backend application that serves both dashboards and APIs, ensuring a shared persistent data source and server-side LLM usage.

2. System Architecture
Backend

Framework: FastAPI (Python)

Responsibilities:

Expose REST APIs for submitting feedback and retrieving submissions

Handle all LLM calls server-side

Persist feedback data using SQLite

Serve frontend HTML, JavaScript, and CSS files

Frontend

Technology: Plain HTML, JavaScript, and CSS

No frameworks (React, Streamlit, Gradio, etc.) are used, in compliance with task constraints.

Frontend files are served by FastAPI using static file mounting.

Deployment Model

A single deployed web application exposes two public URLs:

/ → User Dashboard

/admin → Admin Dashboard

This avoids duplication, ensures shared state, and reflects a realistic production setup.

3. Dashboards
3.1 User Dashboard (Public-Facing)

Features:

Select a star rating (1–5)

Enter a short review

Submit feedback

View an AI-generated response

Clear success and error messages

Behavior:

On submission, the feedback is sent to the backend via a POST API.

The backend invokes an LLM to generate a user-facing response.

The feedback and AI outputs are stored persistently.

3.2 Admin Dashboard (Internal-Facing)

Features:

Displays a live-updating list of all submissions

Shows:

User rating

User review

AI-generated summary

AI-recommended action

Timestamp

Auto-refreshes periodically without manual reload

Purpose:

Enables internal review and analysis of customer feedback

Provides actionable insights generated by the LLM

4. LLM Usage

LLMs are used strictly server-side, as required.

LLM Responsibilities

Generate a user-facing response acknowledging feedback

Produce an internal summary for admins

Suggest a recommended next action for the business

Reliability & Fallback Handling

LLM responses are expected to be probabilistic and occasionally fail (rate limits, formatting issues, safety filters).

The system includes graceful fallback logic:

If the LLM fails, a default safe response and admin note are stored.

The application never crashes due to LLM errors.

This mirrors real-world production systems and satisfies the requirement to handle LLM/API failures gracefully.

5. Data Persistence

Database: SQLite

All submissions are stored in a single persistent database.

Both dashboards read from and write to the same data source, ensuring consistency.

When deployed, a persistent disk is used so data survives restarts and refreshes.

6. API Design & Schemas

All backend endpoints use explicit JSON request and response schemas.

Input validation ensures:

Rating values are within range

Empty or invalid reviews are handled cleanly

Clear HTTP status codes are returned for success and error cases.

7. Deployment

The application is deployed as a single FastAPI service.

Deployment is performed using a cloud platform (e.g., Render), with GitHub as the source repository.

Two public URLs are provided:

User Dashboard URL: /

Admin Dashboard URL: /admin

The deployment:

Loads successfully

Functions without manual intervention

Persists data across refreshes and restarts

8. Summary

This implementation satisfies all Task 2 requirements:

✔ Web-based system

✔ Two fully functional dashboards

✔ Shared persistent data source

✔ Server-side LLM usage

✔ Graceful handling of failures

✔ Production-style architecture

✔ Public URLs for both dashboards

The system prioritizes correctness, robustness, and clarity over unnecessary UI complexity, aligning with real-world engineering best practices.
